import { useState } from "react";
import { evaluateTokens } from "./parser.tsx";
import {
  specialConstants,
  specialVariables,
  operators,
  decorators,
  specialCharacters,
} from "./Keywords.tsx";

const constSet = new Set(specialConstants);
const varSet = new Set(specialVariables);
const opSet = new Set(operators);
const decoSet = new Set(decorators);
const specialSet = new Set(specialCharacters);

import { MathJax, MathJaxContext } from "better-react-mathjax";

export default function LiveMath() {
  const [expr, setExpr] = useState("v = r\\omega");
  const [exprHistory, setHistory] = useState([]);

  const addItem = (insertItem) => {
    setHistory((prevArray) => [...prevArray, insertItem]);
  };

  const clear = () => {
    setHistory((prevArray)) => [];
  };

  // FIX: rename to solve(), use mathEval()
  const solve = () => {
    const tokens = tokenizeExpression(expr);

    try {
      const result = evaluateTokens(tokens, {});
      console.log("Solved:", result);
      addItem(`${expr} = ${result}`);
    } catch (err) {
      console.error(err);
      addItem(`Error: ${err.message}`);
    }
  };

  const renderExpression = (curr_expr, index) => (
    <div key={index} style={{ marginBottom: "0.5rem" }}>
      <MathJax inline>{`\\(${curr_expr}\\)`}</MathJax>
    </div>
  );

  function renderHistory(list) {
    return list.map((item, index) => renderExpression(item, index));
  }

  return (
    <div style={{ textAlign: "center", marginTop: "2rem" }}>
      <h1>History</h1>
      <MathJaxContext>
        <div id="expressionHistory">{renderHistory(exprHistory)}</div>

        {/* FIX: show raw expression, not tokens */}
        <article id="expression_render" style={{ margin: "1rem 0" }}>
          <MathJax inline>{`\\(${expr}\\)`}</MathJax>
        </article>

        <main>
          <input
            id="input"
            type="text"
            value={expr}
            onInput={(e) => setExpr(e.target.value)}
            placeholder="Type LaTeX here..."
            style={{
              padding: "0.5rem",
              fontSize: "1rem",
              textAlign: "center",
              width: "60%",
            }}
          />
          <button
            style={{ marginLeft: "0.5rem", padding: "0.5rem 1rem" }}
            onClick={() => addItem(expr)}
          >
            Save
          </button>

          {/* FIX: use solve() instead of evaluate() */}
          <button
            style={{ marginLeft: "0.5rem", padding: "0.5rem 1rem" }}
            onClick={solve}
          >
            Solve
          </button>
          <button
            style={{ marginLeft: "0.5rem", padding: "0.5rem 1rem" }}
            onClick={clear}
          >
            Clear
          </button>
        </main>
      </MathJaxContext>
    </div>
  );
}

/* ---------------- TOKENIZING LOGIC ---------------- */

function tokenize(text) {
  if (constSet.has(text)) {
    return { type: "constant", value: text };
  } else if (varSet.has(text)) {
    return { type: "variable", value: text };
  } else if (opSet.has(text)) {
    return { type: "operator", value: text };
  } else if (decoSet.has(text)) {
    return { type: "decorator", value: text };
  } else if (specialSet.has(text)) {
    return { type: "special", value: text };
  } else if (!isNaN(Number(text))) {
    return { type: "number", value: Number(text) };
  }
  return { type: "identifier", value: text };
}

// FIX: expressionToMathJax should return the original MathJax string,
// not a token list. So we remove it entirely from rendering.

function tokenizeExpression(expression) {
  return expression
    .split(" ")
    .flatMap((tok) => tok.split("\\"))
    .filter((tok) => tok.length > 0)
    .map(tokenize);
}
